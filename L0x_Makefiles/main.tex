\documentclass[graphics]{beamer}
\usepackage{graphicx}
\usepackage{listings} % Syntax highlighing
\usepackage{fancyvrb} % Inline verbatim
\usepackage{hyperref} % Hyperlinks
\hypersetup{pdfpagemode=FullScreen}

\usepackage[normalem]{ulem}               % to striketrhourhg text
\newcommand\redout{\bgroup\markoverwith
{\textcolor{red}{\rule[0.5ex]{2pt}{0.8pt}}}\ULon}

% header in tables
\newcommand*{\thead}[1]{\multicolumn{1}{c}{\bfseries #1}}

% used for arrows from one point in the slide to another
\usepackage{tikz}
\usetikzlibrary{arrows,shapes,tikzmark}

\usetheme{Boadilla}
\title{Lecture x: Introduction to Makefiles}
\author{UMBC CMSC 104}
\date{Th 12 May 2022}

\begin{document}

\begin{frame}{}
\centering
    Introduction to Makefiles
\end{frame}

\begin{frame}{Introduction to Makefiles}
    Topics:
    \begin{itemize}
        \item Compiling code
        \item Make
        \item Software development process
    \end{itemize}
\end{frame}

\section*{Compiling Code}
\begin{frame}{Compiling Code}
    \begin{itemize}
        \item \texttt{gcc my\_program.c}
        \begin{itemize}
            \item Yields ``a.out''
        \end{itemize}
        \item \texttt{gcc -c my\_program.c}
        \begin{itemize}
            \item Yields ``my\_program.o''
        \end{itemize}
        \item \texttt{gcc my\_program.o -o my\_program}
        \begin{itemize}
            \item Yields ``my\_program''
        \end{itemize}
    \end{itemize} ~~ \\
    Two paths shown:
    \begin{itemize}
        \item Source code $\rightarrow$ executable
        \item Source code $\rightarrow$ object file(s) $\rightarrow$ executable
    \end{itemize}
\end{frame}

\begin{frame}{Multiple Files}
    Often, programs are too large for one .c file, in which case similar parts are put in to their own .c files. But the code still works together.
    \begin{itemize}
        \item \texttt{gcc -c my\_program.c}
        \begin{itemize}
            \item Yields ``my\_program.o''
        \end{itemize}
        \item \texttt{gcc -c main.c}
        \begin{itemize}
            \item Yields ``main.o''
        \end{itemize}
        \item \texttt{gcc my\_program.o main.o -o my\_program}
        \begin{itemize}
            \item Yields ``my\_program''
            \item Combined code from main.c \& my\_program.c into one executable file, despite being in separate source code files.
        \end{itemize}
    \end{itemize}
\end{frame}

\section*{Make}
\begin{frame}{Makefile}
    Introducing \textit{Make}!
    \begin{itemize}
        \item The file is called ``Makefile'' and is in the main directory of your code.
        \item It contains the commands needed to compile everything
        \begin{itemize}
            \item And often the commands to clean up after (remove the executable \& intermediate .o files)
        \end{itemize}
        \item Easier than remembering the commands
        \item Only compiles what's needed
        \begin{itemize}
            \item If you only changed one .c file, you don't need to re-compile the other .c files each time you want to test the code.
        \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Makefile example}
\begin{verbatim}
OPTS=-Wall
all: my_program
my_program: main.o part1.o part2.o
    gcc -o my_program main.o part1.o part2.o ${OPTS}
main.o: main.c part1.h
    gcc -o main.c ${OPTS}
part1.o: part1.c part1.h part2.h
    gcc -o part1.c ${OPTS}
part2.o: part2.c part2.h
    gcc -o part2.c ${OPTS}

.phony: clean
clean:
    rm *.o my_program
\end{verbatim}
\end{frame}

\section*{Software Development}
\begin{frame}{Build Environments}
    \begin{itemize}
        \item C, C++: AutoTools, Make, CMake, others
        \item Java: Ant, Maven, Gradle
    \end{itemize}
    The person compiling someone elseâ€™s code shouldn't have to worry about the needed compiler flags, build order, etc.
    \\ ~~ \\
    Whatever the language or the build environment, the goal is to make easily reproducible builds regardless of the environment.
    \\ ~~ \\
    \footnotesize
    And so many more: \url{https://en.wikipedia.org/wiki/List\_of\_build\_automation\_software}
\end{frame}

\begin{frame}{Software Sharing \& Collaboration}
    People, independent developers, small teams all the way to large companies and big projects use code management software to store and manage code.  These programs are said to host \textit{code repositories}, with the most popular being \texttt{git}. It allows for people to keep track when/how a file was created/edited and by whom. It shows all the files and the history for each.
    \\ ~~ \\
    A great example is that of the Linux kernel hosted on the popular software repository hosting website, Github. \\
    \url{https://github.com/torvalds/linux}
\end{frame}

\end{document}